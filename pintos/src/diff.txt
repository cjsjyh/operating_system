diff --git a/pintos/20151619.docx b/pintos/20151619.docx
index 0633efb..3ce8a5d 100644
Binary files a/pintos/20151619.docx and b/pintos/20151619.docx differ
diff --git a/pintos/os_prj2_20151619.tar.gz b/pintos/os_prj2_20151619.tar.gz
deleted file mode 100644
index 51d691b..0000000
Binary files a/pintos/os_prj2_20151619.tar.gz and /dev/null differ
diff --git a/pintos/os_prj3_20151619.tar.gz b/pintos/os_prj3_20151619.tar.gz
new file mode 100644
index 0000000..c3ac541
Binary files /dev/null and b/pintos/os_prj3_20151619.tar.gz differ
diff --git a/pintos/src/devices/timer.c b/pintos/src/devices/timer.c
index 8b92341..574f6d3 100644
--- a/pintos/src/devices/timer.c
+++ b/pintos/src/devices/timer.c
@@ -17,6 +17,8 @@
 #error TIMER_FREQ <= 1000 recommended
 #endif
 
+static struct list sleep_list;
+
 /* Number of timer ticks since OS booted. */
 static int64_t ticks;
 
@@ -35,6 +37,7 @@ static void real_time_delay (int64_t num, int32_t denom);
 void
 timer_init (void) 
 {
+  list_init(&sleep_list);
   pit_configure_channel (0, 2, TIMER_FREQ);
   intr_register_ext (0x20, timer_interrupt, "8254 Timer");
 }
@@ -92,8 +95,13 @@ timer_sleep (int64_t ticks)
   int64_t start = timer_ticks ();
 
   ASSERT (intr_get_level () == INTR_ON);
-  while (timer_elapsed (start) < ticks) 
-    thread_yield ();
+  enum intr_level old_level;
+  old_level = intr_disable();
+  thread_current()->wakeup_time = start + ticks;
+  list_push_back(&sleep_list, &thread_current()->elem);
+  thread_block();
+  intr_set_level(old_level);
+
 }
 
 /* Sleeps for approximately MS milliseconds.  Interrupts must be
@@ -171,6 +179,27 @@ static void
 timer_interrupt (struct intr_frame *args UNUSED)
 {
   ticks++;
+
+  struct thread *t;
+  for (struct list_elem* e=list_begin(&sleep_list); e!=list_end(&sleep_list); ) {
+    t = list_entry(e, struct thread, elem);
+ 
+    if (t->wakeup_time <= ticks) {
+      e = list_remove(e);
+      thread_unblock(t);
+    } else {
+      e = list_next(e);
+    }   
+  }
+
+  if(thread_prior_aging || thread_mlfqs){
+    thread_current()->recent_cpu += int_to_fixed(1);
+    if (timer_ticks() % TIMER_FREQ == 0)
+      update_load_and_recent_cpu();
+    if (timer_ticks() % 4 == 0)
+      update_priority();
+  }
+
   thread_tick ();
 }
 
diff --git a/pintos/src/devices/timer.h b/pintos/src/devices/timer.h
index cd3d6bb..e9497d7 100644
--- a/pintos/src/devices/timer.h
+++ b/pintos/src/devices/timer.h
@@ -3,7 +3,8 @@
 
 #include <round.h>
 #include <stdint.h>
-
+#include <stdbool.h>
+extern bool thread_prior_aging;
 /* Number of timer interrupts per second. */
 #define TIMER_FREQ 100
 
diff --git a/pintos/src/examples/additional b/pintos/src/examples/additional
new file mode 100755
index 0000000..47a3c5f
Binary files /dev/null and b/pintos/src/examples/additional differ
diff --git a/pintos/src/examples/additional.o b/pintos/src/examples/additional.o
new file mode 100644
index 0000000..4652883
Binary files /dev/null and b/pintos/src/examples/additional.o differ
diff --git a/pintos/src/examples/bubsort.o b/pintos/src/examples/bubsort.o
new file mode 100644
index 0000000..4a5b8ed
Binary files /dev/null and b/pintos/src/examples/bubsort.o differ
diff --git a/pintos/src/examples/cat.o b/pintos/src/examples/cat.o
new file mode 100644
index 0000000..e98bc73
Binary files /dev/null and b/pintos/src/examples/cat.o differ
diff --git a/pintos/src/examples/cmp.o b/pintos/src/examples/cmp.o
new file mode 100644
index 0000000..f40acd1
Binary files /dev/null and b/pintos/src/examples/cmp.o differ
diff --git a/pintos/src/examples/cp.o b/pintos/src/examples/cp.o
new file mode 100644
index 0000000..23c417e
Binary files /dev/null and b/pintos/src/examples/cp.o differ
diff --git a/pintos/src/examples/echo.o b/pintos/src/examples/echo.o
new file mode 100644
index 0000000..db99b1a
Binary files /dev/null and b/pintos/src/examples/echo.o differ
diff --git a/pintos/src/examples/halt.o b/pintos/src/examples/halt.o
new file mode 100644
index 0000000..fdfcc31
Binary files /dev/null and b/pintos/src/examples/halt.o differ
diff --git a/pintos/src/examples/hex-dump.o b/pintos/src/examples/hex-dump.o
new file mode 100644
index 0000000..d144ad3
Binary files /dev/null and b/pintos/src/examples/hex-dump.o differ
diff --git a/pintos/src/examples/lib/arithmetic.o b/pintos/src/examples/lib/arithmetic.o
new file mode 100644
index 0000000..0fac7df
Binary files /dev/null and b/pintos/src/examples/lib/arithmetic.o differ
diff --git a/pintos/src/examples/lib/debug.o b/pintos/src/examples/lib/debug.o
new file mode 100644
index 0000000..9dc1581
Binary files /dev/null and b/pintos/src/examples/lib/debug.o differ
diff --git a/pintos/src/examples/lib/random.o b/pintos/src/examples/lib/random.o
new file mode 100644
index 0000000..d7cc132
Binary files /dev/null and b/pintos/src/examples/lib/random.o differ
diff --git a/pintos/src/examples/lib/stdio.o b/pintos/src/examples/lib/stdio.o
new file mode 100644
index 0000000..4c8d365
Binary files /dev/null and b/pintos/src/examples/lib/stdio.o differ
diff --git a/pintos/src/examples/lib/stdlib.o b/pintos/src/examples/lib/stdlib.o
new file mode 100644
index 0000000..71e5a0d
Binary files /dev/null and b/pintos/src/examples/lib/stdlib.o differ
diff --git a/pintos/src/examples/lib/string.o b/pintos/src/examples/lib/string.o
new file mode 100644
index 0000000..4ce650e
Binary files /dev/null and b/pintos/src/examples/lib/string.o differ
diff --git a/pintos/src/examples/lib/user/console.o b/pintos/src/examples/lib/user/console.o
new file mode 100644
index 0000000..ee6dfe3
Binary files /dev/null and b/pintos/src/examples/lib/user/console.o differ
diff --git a/pintos/src/examples/lib/user/debug.o b/pintos/src/examples/lib/user/debug.o
new file mode 100644
index 0000000..d6282e8
Binary files /dev/null and b/pintos/src/examples/lib/user/debug.o differ
diff --git a/pintos/src/examples/lib/user/entry.o b/pintos/src/examples/lib/user/entry.o
new file mode 100644
index 0000000..bdba910
Binary files /dev/null and b/pintos/src/examples/lib/user/entry.o differ
diff --git a/pintos/src/examples/lib/user/syscall.o b/pintos/src/examples/lib/user/syscall.o
new file mode 100644
index 0000000..3fa08c5
Binary files /dev/null and b/pintos/src/examples/lib/user/syscall.o differ
diff --git a/pintos/src/examples/lib/ustar.o b/pintos/src/examples/lib/ustar.o
new file mode 100644
index 0000000..78ed065
Binary files /dev/null and b/pintos/src/examples/lib/ustar.o differ
diff --git a/pintos/src/examples/libc.a b/pintos/src/examples/libc.a
new file mode 100644
index 0000000..15e305e
Binary files /dev/null and b/pintos/src/examples/libc.a differ
diff --git a/pintos/src/examples/lineup.o b/pintos/src/examples/lineup.o
new file mode 100644
index 0000000..f513a95
Binary files /dev/null and b/pintos/src/examples/lineup.o differ
diff --git a/pintos/src/examples/ls.o b/pintos/src/examples/ls.o
new file mode 100644
index 0000000..4678cdc
Binary files /dev/null and b/pintos/src/examples/ls.o differ
diff --git a/pintos/src/examples/matmult.o b/pintos/src/examples/matmult.o
new file mode 100644
index 0000000..cd72d15
Binary files /dev/null and b/pintos/src/examples/matmult.o differ
diff --git a/pintos/src/examples/mcat.o b/pintos/src/examples/mcat.o
new file mode 100644
index 0000000..684945a
Binary files /dev/null and b/pintos/src/examples/mcat.o differ
diff --git a/pintos/src/examples/mcp.o b/pintos/src/examples/mcp.o
new file mode 100644
index 0000000..68fc562
Binary files /dev/null and b/pintos/src/examples/mcp.o differ
diff --git a/pintos/src/examples/mkdir.o b/pintos/src/examples/mkdir.o
new file mode 100644
index 0000000..fbce228
Binary files /dev/null and b/pintos/src/examples/mkdir.o differ
diff --git a/pintos/src/examples/pwd.o b/pintos/src/examples/pwd.o
new file mode 100644
index 0000000..99bc69a
Binary files /dev/null and b/pintos/src/examples/pwd.o differ
diff --git a/pintos/src/examples/recursor.o b/pintos/src/examples/recursor.o
new file mode 100644
index 0000000..b8f4a2c
Binary files /dev/null and b/pintos/src/examples/recursor.o differ
diff --git a/pintos/src/examples/rm.o b/pintos/src/examples/rm.o
new file mode 100644
index 0000000..8b50a63
Binary files /dev/null and b/pintos/src/examples/rm.o differ
diff --git a/pintos/src/examples/shell.o b/pintos/src/examples/shell.o
new file mode 100644
index 0000000..7d96c76
Binary files /dev/null and b/pintos/src/examples/shell.o differ
diff --git a/pintos/src/tests/threads/Make.tests b/pintos/src/tests/threads/Make.tests
index 4569035..29e9188 100644
--- a/pintos/src/tests/threads/Make.tests
+++ b/pintos/src/tests/threads/Make.tests
@@ -3,10 +3,10 @@
 # Test names.
 tests/threads_TESTS = $(addprefix tests/threads/,alarm-single		\
 alarm-multiple alarm-simultaneous alarm-priority alarm-zero		\
-alarm-negative priority-change priority-donate-one			\
+alarm-negative priority-change priority-change-2 priority-donate-one			\
 priority-donate-multiple priority-donate-multiple2			\
 priority-donate-nest priority-donate-sema priority-donate-lower		\
-priority-fifo priority-preempt priority-sema priority-condvar		\
+priority-fifo priority-preempt priority-sema priority-aging priority-condvar		\
 priority-donate-chain                                                   \
 mlfqs-load-1 mlfqs-load-60 mlfqs-load-avg mlfqs-recent-1 mlfqs-fair-2	\
 mlfqs-fair-20 mlfqs-nice-2 mlfqs-nice-10 mlfqs-block)
@@ -19,6 +19,7 @@ tests/threads_SRC += tests/threads/alarm-priority.c
 tests/threads_SRC += tests/threads/alarm-zero.c
 tests/threads_SRC += tests/threads/alarm-negative.c
 tests/threads_SRC += tests/threads/priority-change.c
+tests/threads_SRC += tests/threads/priority-change-2.c
 tests/threads_SRC += tests/threads/priority-donate-one.c
 tests/threads_SRC += tests/threads/priority-donate-multiple.c
 tests/threads_SRC += tests/threads/priority-donate-multiple2.c
@@ -26,8 +27,10 @@ tests/threads_SRC += tests/threads/priority-donate-nest.c
 tests/threads_SRC += tests/threads/priority-donate-sema.c
 tests/threads_SRC += tests/threads/priority-donate-lower.c
 tests/threads_SRC += tests/threads/priority-fifo.c
+tests/threads_SRC += tests/threads/priority-lifo.c
 tests/threads_SRC += tests/threads/priority-preempt.c
 tests/threads_SRC += tests/threads/priority-sema.c
+tests/threads_SRC += tests/threads/priority-aging.c
 tests/threads_SRC += tests/threads/priority-condvar.c
 tests/threads_SRC += tests/threads/priority-donate-chain.c
 tests/threads_SRC += tests/threads/mlfqs-load-1.c
@@ -37,6 +40,9 @@ tests/threads_SRC += tests/threads/mlfqs-recent-1.c
 tests/threads_SRC += tests/threads/mlfqs-fair.c
 tests/threads_SRC += tests/threads/mlfqs-block.c
 
+AGING_OUTPUTS = tests/threads/priority-aging.output
+$(AGING_OUTPUTS): KERNELFLAGS += -aging
+
 MLFQS_OUTPUTS = 				\
 tests/threads/mlfqs-load-1.output		\
 tests/threads/mlfqs-load-60.output		\
@@ -50,4 +56,3 @@ tests/threads/mlfqs-block.output
 
 $(MLFQS_OUTPUTS): KERNELFLAGS += -mlfqs
 $(MLFQS_OUTPUTS): TIMEOUT = 480
-
diff --git a/pintos/src/tests/threads/mlfqs-load-1.c b/pintos/src/tests/threads/mlfqs-load-1.c
index a39eea2..6b230aa 100644
--- a/pintos/src/tests/threads/mlfqs-load-1.c
+++ b/pintos/src/tests/threads/mlfqs-load-1.c
@@ -31,12 +31,12 @@ test_mlfqs_load_1 (void)
       load_avg = thread_get_load_avg ();
       ASSERT (load_avg >= 0);
       elapsed = timer_elapsed (start_time) / TIMER_FREQ;
-      if (load_avg > 100)
+      if (load_avg > 50)
+        break;
+      else if (load_avg > 100)
         fail ("load average is %d.%02d "
               "but should be between 0 and 1 (after %d seconds)",
               load_avg / 100, load_avg % 100, elapsed);
-      else if (load_avg > 50)
-        break;
       else if (elapsed > 45)
         fail ("load average stayed below 0.5 for more than 45 seconds");
     }
diff --git a/pintos/src/tests/threads/priority-aging.c b/pintos/src/tests/threads/priority-aging.c
new file mode 100644
index 0000000..e429d38
--- /dev/null
+++ b/pintos/src/tests/threads/priority-aging.c
@@ -0,0 +1,27 @@
+#include <stdio.h>
+#include "tests/threads/tests.h"
+#include "threads/init.h"
+#include "threads/thread.h"
+
+static thread_func aging_thread;
+
+void
+test_priority_aging (void) 
+{
+  /* This test does not work with the MLFQS. */
+  ASSERT (!thread_mlfqs);
+
+  msg ("Creating a default-priority thread 2.");
+  thread_create ("thread 2", PRI_DEFAULT, aging_thread, NULL);
+  msg ("Main thread change its priority and have just lowered thread 2's priority.");
+  msg ("From now, main thread can't get CPU without aging.");
+  thread_set_priority (PRI_DEFAULT - 2);
+  msg ("But main thread exiting.");
+  msg ("Success!");
+}
+
+static void
+aging_thread (void *aux UNUSED)
+{
+  while (1);
+}
diff --git a/pintos/src/tests/threads/priority-aging.ck b/pintos/src/tests/threads/priority-aging.ck
new file mode 100644
index 0000000..a1d02a4
--- /dev/null
+++ b/pintos/src/tests/threads/priority-aging.ck
@@ -0,0 +1,14 @@
+# -*- perl -*-
+use strict;
+use warnings;
+use tests::tests;
+check_expected ([<<'EOF']);
+(priority-aging) begin
+(priority-aging) Creating a default-priority thread 2.
+(priority-aging) Main thread change its priority and have just lowered thread 2's priority.
+(priority-aging) From now, main thread can't get CPU without aging.
+(priority-aging) But main thread exiting.
+(priority-aging) Success!
+(priority-aging) end
+EOF
+pass;
diff --git a/pintos/src/tests/threads/priority-change-2.c b/pintos/src/tests/threads/priority-change-2.c
new file mode 100644
index 0000000..fd10833
--- /dev/null
+++ b/pintos/src/tests/threads/priority-change-2.c
@@ -0,0 +1,31 @@
+/* Verifies that lowering a thread's priority so that it is no
+   longer the highest-priority thread in the system causes it to
+   yield immediately. */
+
+#include <stdio.h>
+#include "tests/threads/tests.h"
+#include "threads/init.h"
+#include "threads/thread.h"
+
+static thread_func changing_thread;
+
+void
+test_priority_change_2 (void) 
+{
+  /* This test does not work with the MLFQS. */
+  ASSERT (!thread_mlfqs);
+
+  msg ("Creating a low-priority thread 2.");
+  thread_create ("thread 2", PRI_DEFAULT - 2, changing_thread, NULL);
+  msg ("Thread 2 should have just highered its priority.");
+  thread_set_priority (PRI_DEFAULT - 3);
+  msg ("Thread 2 should have just exited.");
+}
+
+static void
+changing_thread (void *aux UNUSED) 
+{
+  msg ("Thread 2 now highering priority.");
+  thread_set_priority (PRI_DEFAULT + 1);
+  msg ("Thread 2 exiting.");
+}
diff --git a/pintos/src/tests/threads/priority-change-2.ck b/pintos/src/tests/threads/priority-change-2.ck
new file mode 100644
index 0000000..edec0c0
--- /dev/null
+++ b/pintos/src/tests/threads/priority-change-2.ck
@@ -0,0 +1,14 @@
+# -*- perl -*-
+use strict;
+use warnings;
+use tests::tests;
+check_expected ([<<'EOF']);
+(priority-change-2) begin
+(priority-change-2) Creating a low-priority thread 2.
+(priority-change-2) Thread 2 should have just highered its priority.
+(priority-change-2) Thread 2 now highering priority.
+(priority-change-2) Thread 2 exiting.
+(priority-change-2) Thread 2 should have just exited.
+(priority-change-2) end
+EOF
+pass;
diff --git a/pintos/src/tests/threads/priority-lifo.c b/pintos/src/tests/threads/priority-lifo.c
new file mode 100644
index 0000000..b39ce67
--- /dev/null
+++ b/pintos/src/tests/threads/priority-lifo.c
@@ -0,0 +1,99 @@
+/* Creates several threads all at the same priority and ensures
+   that they consistently run in the same round-robin order.
+
+   Based on a test originally submitted for Stanford's CS 140 in
+   winter 1999 by by Matt Franklin
+   <startled@leland.stanford.edu>, Greg Hutchins
+   <gmh@leland.stanford.edu>, Yu Ping Hu <yph@cs.stanford.edu>.
+   Modified by arens. */
+
+#include <stdio.h>
+#include "tests/threads/tests.h"
+#include "threads/init.h"
+#include "devices/timer.h"
+#include "threads/malloc.h"
+#include "threads/synch.h"
+#include "threads/thread.h"
+
+struct simple_thread_data 
+  {
+    int id;                     /* Sleeper ID. */
+    int iterations;             /* Iterations so far. */
+    struct lock *lock;          /* Lock on output. */
+    int **op;                   /* Output buffer position. */
+  };
+
+#define THREAD_CNT 16
+#define ITER_CNT 16
+
+static thread_func simple_thread_func;
+
+void
+test_priority_lifo (void) 
+{
+  struct simple_thread_data data[THREAD_CNT];
+  struct lock lock;
+  int *output, *op;
+  int i, cnt;
+
+  /* This test does not work with the MLFQS. */
+  ASSERT (!thread_mlfqs);
+
+  /* Make sure our priority is the default. */
+  ASSERT (thread_get_priority () == PRI_DEFAULT);
+
+  msg ("%d threads will iterate %d times in the same order each time.",
+       THREAD_CNT, ITER_CNT);
+  msg ("If the order varies then there is a bug.");
+
+  output = op = malloc (sizeof *output * THREAD_CNT * ITER_CNT * 2);
+  ASSERT (output != NULL);
+  lock_init (&lock);
+
+  thread_set_priority (PRI_DEFAULT + THREAD_CNT + 1);
+  for (i = 0; i < THREAD_CNT; i++) 
+    {
+      char name[16];
+      struct simple_thread_data *d = data + i;
+      snprintf (name, sizeof name, "%d", i);
+      d->id = i;
+      d->iterations = 0;
+      d->lock = &lock;
+      d->op = &op;
+      thread_create (name, PRI_DEFAULT + 1 + i, simple_thread_func, d);
+    }
+
+  thread_set_priority (PRI_DEFAULT);
+  /* All the other threads now run to termination here. */
+  ASSERT (lock.holder == NULL);
+
+  cnt = 0;
+  for (; output < op; output++) 
+    {
+      struct simple_thread_data *d;
+
+      ASSERT (*output >= 0 && *output < THREAD_CNT);
+      d = data + *output;
+      if (cnt % THREAD_CNT == 0)
+        printf ("(priority-lifo) iteration:");
+      printf (" %d", d->id);
+      if (++cnt % THREAD_CNT == 0)
+        printf ("\n");
+      d->iterations++;
+    }
+}
+
+static void 
+simple_thread_func (void *data_) 
+{
+  struct simple_thread_data *data = data_;
+  int i;
+  
+  for (i = 0; i < ITER_CNT; i++) 
+    {
+      lock_acquire (data->lock);
+      *(*data->op)++ = data->id;
+      lock_release (data->lock);
+      thread_yield ();
+    }
+}
diff --git a/pintos/src/tests/threads/tests.c b/pintos/src/tests/threads/tests.c
index af15aee..3997564 100644
--- a/pintos/src/tests/threads/tests.c
+++ b/pintos/src/tests/threads/tests.c
@@ -18,6 +18,7 @@ static const struct test tests[] =
     {"alarm-zero", test_alarm_zero},
     {"alarm-negative", test_alarm_negative},
     {"priority-change", test_priority_change},
+    {"priority-change-2", test_priority_change_2},
     {"priority-donate-one", test_priority_donate_one},
     {"priority-donate-multiple", test_priority_donate_multiple},
     {"priority-donate-multiple2", test_priority_donate_multiple2},
@@ -26,8 +27,10 @@ static const struct test tests[] =
     {"priority-donate-lower", test_priority_donate_lower},
     {"priority-donate-chain", test_priority_donate_chain},
     {"priority-fifo", test_priority_fifo},
+    {"priority-lifo", test_priority_lifo},
     {"priority-preempt", test_priority_preempt},
     {"priority-sema", test_priority_sema},
+    {"priority-aging", test_priority_aging},
     {"priority-condvar", test_priority_condvar},
     {"mlfqs-load-1", test_mlfqs_load_1},
     {"mlfqs-load-60", test_mlfqs_load_60},
diff --git a/pintos/src/tests/threads/tests.h b/pintos/src/tests/threads/tests.h
index cd9d489..7fe5061 100644
--- a/pintos/src/tests/threads/tests.h
+++ b/pintos/src/tests/threads/tests.h
@@ -12,6 +12,7 @@ extern test_func test_alarm_priority;
 extern test_func test_alarm_zero;
 extern test_func test_alarm_negative;
 extern test_func test_priority_change;
+extern test_func test_priority_change_2;
 extern test_func test_priority_donate_one;
 extern test_func test_priority_donate_multiple;
 extern test_func test_priority_donate_multiple2;
@@ -20,8 +21,10 @@ extern test_func test_priority_donate_nest;
 extern test_func test_priority_donate_lower;
 extern test_func test_priority_donate_chain;
 extern test_func test_priority_fifo;
+extern test_func test_priority_lifo;
 extern test_func test_priority_preempt;
 extern test_func test_priority_sema;
+extern test_func test_priority_aging;
 extern test_func test_priority_condvar;
 extern test_func test_mlfqs_load_1;
 extern test_func test_mlfqs_load_60;
diff --git a/pintos/src/threads/check_list.py b/pintos/src/threads/check_list.py
new file mode 100644
index 0000000..047a598
--- /dev/null
+++ b/pintos/src/threads/check_list.py
@@ -0,0 +1,53 @@
+proj3 = [
+    "alarm-single",
+    "alarm-multiple",
+    "alarm-simultaneous",
+    "alarm-priority",
+    "alarm-zero",
+    "alarm-negative",
+    "priority-change",
+    "priority-change-2",
+    "priority-fifo",
+    "priority-preempt",
+    "priority-sema",
+    "priority-aging",
+    "priority-lifo",
+    "mlfqs-load-1",
+    "mlfqs-load-60",
+    "mlfqs-load-avg",
+    "mlfqs-recent-1",
+    "mlfqs-fair-2",
+    "mlfqs-fair-20",
+    "mlfqs-nice-2",
+    "mlfqs-nice-10",
+    "mlfqs-block"
+]
+
+fp = open("list.txt","r")
+
+results = []
+while True:
+    line = fp.readline()
+    if not line: break
+
+    p_f = line.strip().split(' ')
+    test_case = p_f[1].split('/')[-1]
+    results.append((test_case.strip(), p_f[0].strip()))
+fp.close()
+
+is_all_pass = True
+for check in proj3:
+    found = False
+    for result, p_f in results:
+        #print("Comparing ",check," ",result)
+        if(check == result):
+            found = True
+            if(p_f != "pass"):
+                print("FAILED: ", result)
+                is_all_pass = False
+    if not found:
+        print("NOT FOUND: ", check)
+
+if (is_all_pass):
+    print("***CONGRATULATIONS! ALL PASS!***")
+
diff --git a/pintos/src/threads/init.c b/pintos/src/threads/init.c
index 03dd3b7..9e3689e 100644
--- a/pintos/src/threads/init.c
+++ b/pintos/src/threads/init.c
@@ -256,6 +256,9 @@ parse_options (char **argv)
         random_init (atoi (value));
       else if (!strcmp (name, "-mlfqs"))
         thread_mlfqs = true;
+      else if (!strcmp (name, "-aging")){
+        thread_prior_aging = true;
+      }
 #ifdef USERPROG
       else if (!strcmp (name, "-ul"))
         user_page_limit = atoi (value);
diff --git a/pintos/src/threads/init.h b/pintos/src/threads/init.h
index 8a3df90..29f89f4 100644
--- a/pintos/src/threads/init.h
+++ b/pintos/src/threads/init.h
@@ -6,6 +6,8 @@
 #include <stddef.h>
 #include <stdint.h>
 
+extern bool thread_prior_aging;
+
 /* Page directory with kernel mappings only. */
 extern uint32_t *init_page_dir;
 
diff --git a/pintos/src/threads/list.txt b/pintos/src/threads/list.txt
new file mode 100644
index 0000000..f25c1cf
--- /dev/null
+++ b/pintos/src/threads/list.txt
@@ -0,0 +1,30 @@
+pass tests/threads/mlfqs-block
+pass tests/threads/alarm-single
+pass tests/threads/alarm-multiple
+pass tests/threads/alarm-simultaneous
+pass tests/threads/alarm-priority
+pass tests/threads/alarm-zero
+pass tests/threads/alarm-negative
+pass tests/threads/priority-change
+pass tests/threads/priority-change-2
+FAIL tests/threads/priority-donate-one
+FAIL tests/threads/priority-donate-multiple
+FAIL tests/threads/priority-donate-multiple2
+FAIL tests/threads/priority-donate-nest
+FAIL tests/threads/priority-donate-sema
+FAIL tests/threads/priority-donate-lower
+pass tests/threads/priority-fifo
+pass tests/threads/priority-preempt
+pass tests/threads/priority-sema
+pass tests/threads/priority-aging
+FAIL tests/threads/priority-condvar
+FAIL tests/threads/priority-donate-chain
+pass tests/threads/mlfqs-load-1
+pass tests/threads/mlfqs-load-60
+pass tests/threads/mlfqs-load-avg
+pass tests/threads/mlfqs-recent-1
+pass tests/threads/mlfqs-fair-2
+pass tests/threads/mlfqs-fair-20
+pass tests/threads/mlfqs-nice-2
+pass tests/threads/mlfqs-nice-10
+pass tests/threads/mlfqs-block
\ No newline at end of file
diff --git a/pintos/src/threads/result.txt b/pintos/src/threads/result.txt
new file mode 100644
index 0000000..2ace459
--- /dev/null
+++ b/pintos/src/threads/result.txt
@@ -0,0 +1,7 @@
+cd build && make check
+make[1]: Entering directory '/sogang/under/cse20151619/pintos/pintos/src/threads/build'
+gcc -m32 -c ../../threads/thread.c -o threads/thread.o -g -msoft-float -O -march=i686 -fno-stack-protector -nostdinc -I../.. -I../../lib -I../../lib/kernel -Wall -W -Wstrict-prototypes -Wmissing-prototypes -Wsystem-headers  -MMD -MF threads/thread.d
+gcc -m32 -c ../../threads/interrupt.c -o threads/interrupt.o -g -msoft-float -O -march=i686 -fno-stack-protector -nostdinc -I../.. -I../../lib -I../../lib/kernel -Wall -W -Wstrict-prototypes -Wmissing-prototypes -Wsystem-headers  -MMD -MF threads/interrupt.d
+gcc -m32 -c ../../threads/synch.c -o threads/synch.o -g -msoft-float -O -march=i686 -fno-stack-protector -nostdinc -I../.. -I../../lib -I../../lib/kernel -Wall -W -Wstrict-prototypes -Wmissing-prototypes -Wsystem-headers  -MMD -MF threads/synch.d
+gcc -m32 -c ../../devices/timer.c -o devices/timer.o -g -msoft-float -O -march=i686 -fno-stack-protector -nostdinc -I../.. -I../../lib -I../../lib/kernel -Wall -W -Wstrict-prototypes -Wmissing-prototypes -Wsystem-headers  -MMD -MF devices/timer.d
+make[1]: Leaving directory '/sogang/under/cse20151619/pintos/pintos/src/threads/build'
diff --git a/pintos/src/threads/synch.c b/pintos/src/threads/synch.c
index 317c68a..cdd95d7 100644
--- a/pintos/src/threads/synch.c
+++ b/pintos/src/threads/synch.c
@@ -109,15 +109,31 @@ void
 sema_up (struct semaphore *sema) 
 {
   enum intr_level old_level;
+  struct thread *t, *t_max;
+  struct list_elem *e, *e_max;
+
 
   ASSERT (sema != NULL);
 
   old_level = intr_disable ();
-  if (!list_empty (&sema->waiters)) 
-    thread_unblock (list_entry (list_pop_front (&sema->waiters),
-                                struct thread, elem));
+  if (!list_empty (&sema->waiters)) {
+    e = e_max = list_begin(&sema->waiters);
+    t_max = list_entry(e, struct thread, elem);
+    for (e = list_next(e); e != list_end(&sema->waiters); e = list_next(e)){
+      t = list_entry(e, struct thread, elem);
+      if(t_max->priority < t->priority){
+        t_max = t;
+        e_max = e;
+      }
+    }
+    list_remove(e_max);
+    thread_unblock(t_max);
+  }
+    //thread_unblock (list_entry (list_pop_front (&sema->waiters),struct thread, elem));
   sema->value++;
   intr_set_level (old_level);
+
+  thread_yield();
 }
 
 static void sema_test_helper (void *sema_);
diff --git a/pintos/src/threads/thread.c b/pintos/src/threads/thread.c
index 7bcf6a7..5a911ca 100644
--- a/pintos/src/threads/thread.c
+++ b/pintos/src/threads/thread.c
@@ -12,6 +12,9 @@
 #include "threads/switch.h"
 #include "threads/synch.h"
 #include "threads/vaddr.h"
+
+#define FRACTION (1<<14)
+
 #ifdef USERPROG
 #include "userprog/process.h"
 #include "userprog/syscall.h"
@@ -31,6 +34,8 @@ static struct list ready_list;
 static struct list all_list;
 
 static struct list process_info_list;
+// fixed-point
+static int load_avg;
 
 /* Idle thread. */
 static struct thread *idle_thread;
@@ -59,6 +64,8 @@ static long long user_ticks;    /* # of timer ticks in user programs. */
 #define TIME_SLICE 4            /* # of timer ticks to give each thread. */
 static unsigned thread_ticks;   /* # of timer ticks since last yield. */
 
+bool thread_prior_aging;
+
 /* If false (default), use round-robin scheduler.
    If true, use multi-level feedback queue scheduler.
    Controlled by kernel command-line option "-o mlfqs". */
@@ -147,6 +154,7 @@ thread_init (void)
 {
   ASSERT (intr_get_level () == INTR_OFF);
 
+  load_avg = 0;
   lock_init (&tid_lock);
   list_init (&ready_list);
   list_init (&all_list);
@@ -155,6 +163,8 @@ thread_init (void)
   /* Set up a thread structure for the running thread. */
   initial_thread = running_thread ();
   init_thread (initial_thread, "main", PRI_DEFAULT);
+  initial_thread->nice = 0;
+  initial_thread->recent_cpu = 0;
   initial_thread->status = THREAD_RUNNING;
   initial_thread->tid = allocate_tid ();
 }
@@ -196,6 +206,11 @@ thread_tick (void)
   /* Enforce preemption. */
   if (++thread_ticks >= TIME_SLICE)
     intr_yield_on_return ();
+
+  #ifndef USERPROG
+  if (thread_prior_aging == true)
+    thread_aging();
+  #endif
 }
 
 /* Prints thread statistics. */
@@ -276,13 +291,16 @@ thread_create (const char *name, int priority,
   list_init(&pnew->file_list);
   list_push_back(&process_info_list,&pnew->elem);
 
+  #ifdef USERPROG
   t->executable_file = NULL;
+  #endif
 
   /* Add to run queue. */
-thread_unblock (t);
+  thread_unblock (t);
+
+  if(priority > thread_get_priority())
+    thread_yield();
 
-  if(THREAD_DEBUG_MODE)
-	  printf("------------THREAD CREATE %d--------------\n",tid);
 
   return tid;
 }
@@ -320,7 +338,8 @@ thread_unblock (struct thread *t)
 
   old_level = intr_disable ();
   ASSERT (t->status == THREAD_BLOCKED);
-  list_push_back (&ready_list, &t->elem);
+  list_insert_ordered(&ready_list, &t->elem, compare_priority, NULL);
+  //list_push_back (&ready_list, &t->elem);
   t->status = THREAD_READY;
   intr_set_level (old_level);
 }
@@ -414,7 +433,8 @@ thread_yield (void)
 
   old_level = intr_disable ();
   if (cur != idle_thread) 
-    list_push_back (&ready_list, &cur->elem);
+    list_insert_ordered(&ready_list, &cur->elem, compare_priority, NULL);
+    //list_push_back (&ready_list, &cur->elem);
   cur->status = THREAD_READY;
   schedule ();
   intr_set_level (old_level);
@@ -441,7 +461,13 @@ thread_foreach (thread_action_func *func, void *aux)
 void
 thread_set_priority (int new_priority) 
 {
+  int thread_priority = thread_current()->priority;
+  if (thread_mlfqs)
+    return;
+
   thread_current ()->priority = new_priority;
+  if (new_priority < thread_priority)
+    thread_yield();
 }
 
 /* Returns the current thread's priority. */
@@ -453,35 +479,41 @@ thread_get_priority (void)
 
 /* Sets the current thread's nice value to NICE. */
 void
-thread_set_nice (int nice UNUSED) 
+thread_set_nice (int nice) 
 {
-  /* Not yet implemented. */
+  struct thread* t = thread_current();
+  t->nice = nice;
+  t->priority = fixed_to_int(int_to_fixed(PRI_MAX) - (t->recent_cpu / 4) - (2 * int_to_fixed(t->nice)));
+  if (t->priority > PRI_MAX)
+      t->priority = PRI_MAX;
+  else if (t->priority < PRI_MIN)
+      t->priority = PRI_MIN;
+
+  if (t->priority < get_max_priority())
+      thread_yield();
 }
 
 /* Returns the current thread's nice value. */
 int
 thread_get_nice (void) 
 {
-  /* Not yet implemented. */
-  return 0;
+  return thread_current()->nice;
 }
 
 /* Returns 100 times the system load average. */
 int
 thread_get_load_avg (void) 
 {
-  /* Not yet implemented. */
-  return 0;
+  return 100 * load_avg / FRACTION;
 }
 
 /* Returns 100 times the current thread's recent_cpu value. */
 int
 thread_get_recent_cpu (void) 
 {
-  /* Not yet implemented. */
-  return 0;
+ return 100 * thread_current()->recent_cpu / FRACTION; 
 }
-
+
 /* Idle thread.  Executes when no other thread is ready to run.
 
    The idle thread is initially put on the ready list by
@@ -568,6 +600,9 @@ init_thread (struct thread *t, const char *name, int priority)
   t->priority = priority;
   t->magic = THREAD_MAGIC;
   list_push_back (&all_list, &t->allelem);
+
+  t->recent_cpu = running_thread()->recent_cpu;
+  t->nice = running_thread()->nice;
 }
 
 /* Allocates a SIZE-byte frame at the top of thread T's stack and
@@ -659,6 +694,8 @@ schedule (void)
   struct thread *next = next_thread_to_run ();
   struct thread *prev = NULL;
 
+  //print("\n**next: %d\n", next);
+
   ASSERT (intr_get_level () == INTR_OFF);
   ASSERT (cur->status != THREAD_RUNNING);
   ASSERT (is_thread (next));
@@ -685,3 +722,74 @@ allocate_tid (void)
 /* Offset of `stack' member within `struct thread'.
    Used by switch.S, which can't figure it out on its own. */
 uint32_t thread_stack_ofs = offsetof (struct thread, stack);
+
+bool compare_priority(const struct list_elem* left, const struct list_elem* right, void* aux) {
+  struct thread *thread_left = list_entry(left, struct thread, elem);
+  struct thread *thread_right = list_entry(right, struct thread, elem);
+  return thread_left->priority > thread_right->priority;
+}
+
+void thread_aging(){
+
+}
+
+int int_to_fixed(int i){
+  return i*FRACTION;
+}
+
+int fixed_to_int(int f){
+  return f/FRACTION;
+}
+
+// returns fixed point result
+int fixed_mult(int f1, int f2){
+  int64_t temp = f1;
+  temp = temp * f2 / FRACTION;
+  return (int)temp;
+}
+
+// returns fixed point result
+int fixed_div(int f1, int f2){
+  int64_t temp = f1;
+  temp = temp * FRACTION / f2;
+  return (int)temp;
+}
+int get_max_priority() {
+  if (!list_empty(&ready_list)){
+    struct thread *t = list_entry(list_front(&ready_list), struct thread, elem);
+    return t->priority;
+  }
+  return -1;
+}
+
+void update_load_and_recent_cpu() {
+  int ready_threads = list_size(&ready_list);
+
+  if(thread_current() != idle_thread)
+    ready_threads += 1; 
+  
+  // fixed_point
+  load_avg = (59 * load_avg + int_to_fixed(ready_threads)) / 60;
+
+  for (struct list_elem* e = list_begin(&all_list); e != list_end(&all_list); e = list_next(e)){
+    struct thread *t = list_entry(e, struct thread, allelem);
+    if (t != idle_thread){
+      int temp = fixed_div( 2 * load_avg, 2 * load_avg + int_to_fixed(1));
+      temp = fixed_mult(temp, t->recent_cpu) + int_to_fixed(t->nice);
+      t->recent_cpu = temp;
+    }
+  }
+}
+
+void update_priority(){
+  for (struct list_elem* e = list_begin(&all_list); e != list_end(&all_list); e = list_next(e)){
+    struct thread *t = list_entry(e, struct thread, allelem);
+    t->priority = fixed_to_int(int_to_fixed(PRI_MAX) - (t->recent_cpu / 4) - int_to_fixed(t->nice * 2));
+    if ( t->priority > PRI_MAX )
+      t->priority = PRI_MAX;
+    else if ( t->priority < PRI_MIN )
+      t->priority = PRI_MIN;
+  }
+  if (thread_current()->priority < get_max_priority())
+    intr_yield_on_return();
+}
\ No newline at end of file
diff --git a/pintos/src/threads/thread.h b/pintos/src/threads/thread.h
index 8735175..cebd07f 100644
--- a/pintos/src/threads/thread.h
+++ b/pintos/src/threads/thread.h
@@ -6,6 +6,9 @@
 #include <stdint.h>
 #include "threads/synch.h"
 
+#ifndef USERPROG
+extern bool thread_prior_aging;
+#endif
 
 /* States in a thread's life cycle. */
 enum thread_status
@@ -84,22 +87,25 @@ typedef int tid_t;
    blocked state is on a semaphore wait list. */
 struct thread
   {
-    /* Owned by thread.c. */
-    tid_t tid;                          /* Thread identifier. */
-    enum thread_status status;          /* Thread state. */
-    char name[16];                      /* Name (for debugging purposes). */
-    uint8_t *stack;                     /* Saved stack pointer. */
-    int priority;                       /* Priority. */
-    struct list_elem allelem;           /* List element for all threads list. */
-
-    /* Shared between thread.c and synch.c. */
-    struct list_elem elem;              /* List element. */
-
+   /* Owned by thread.c. */
+   tid_t tid;                          /* Thread identifier. */
+   enum thread_status status;          /* Thread state. */
+   char name[16];                      /* Name (for debugging purposes). */
+   uint8_t *stack;                     /* Saved stack pointer. */
+   int priority;                       /* Priority. */
+   struct list_elem allelem;           /* List element for all threads list. */
+
+   int64_t wakeup_time;
+   int recent_cpu; // fixed-point
+   int nice; // integer
+
+   /* Shared between thread.c and synch.c. */
+   struct list_elem elem;              /* List element. */
 	struct list_elem hiselem;
 
-#ifdef USERPROG
+   #ifdef USERPROG
     /* Owned by userprog/process.c. */
-    uint32_t *pagedir;                  /* Page directory. */
+   uint32_t *pagedir;                  /* Page directory. */
 	struct file *executable_file;
 	#endif
 
@@ -167,4 +173,15 @@ int thread_get_load_avg (void);
 struct process_info *process_info_find(tid_t tid);
 struct fd_info *fd_info_find(int fd);
 int process_exit_status(int status);
+bool compare_priority(const struct list_elem*, const struct list_elem*, void*);
+
+
+int int_to_fixed(int i);
+int fixed_to_int(int f);
+int fixed_mult(int, int);
+int fixed_div(int, int);
+void thread_aging(void);
+int get_max_priority(void);
+void update_load_and_recent_cpu(void);
+void update_priority(void);
 #endif /* threads/thread.h */
